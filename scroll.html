<!DOCTYPE html>
<html>

<head>
    <title>A-Frame Scene with Boxes</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>


    <script>
        AFRAME.registerComponent('log-when-loaded', {
            init: function () {
                console.log('Component has been loaded');
                cameraEL = document.querySelector('a-camera')
                console.log(cameraEL)
                // cameraEL.removeAttribute('look-controls')
                camera = cameraEL.components.camera.camera
                // camera.fov = 75
                camera.far = 1000
                camera.near = 0.5
                camera.position.z = 5
                scene = document.querySelector('a-scene')
                renderer = scene.renderer

                function onWindowResize() {
                    const camera = cameraEl.getObject3D('camera');

                    if (!camera) {
                        console.error('Camera not found');
                        return;
                    }

                    if (typeof updateCubePosition == 'undefined') {
                        console.error('updateCubePosition not found');
                        return;
                    }
                    if (typeof centerScrollbar == 'undefined') {
                        console.error('centerScrollbar not found');
                        return;
                    }

                    renderer.setSize(window.innerWidth, window.innerHeight);

                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();

                    // camera.aspect = window.innerWidth / window.innerHeight;
                    // camera.updateProjectionMatrix();

                    updateCubePosition();
                    // centerScrollbar()
                }

                window.addEventListener('resize', onWindowResize, false);

                if (typeof updateCubePosition !== 'undefined') {
                    updateCubePosition();
                }


            }
        });
    </script>
    <script>
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
    </script>
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            display: flex;
            justify-content: center;
            align-items: end;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f000;
        }

        #dom-overlay {
            position: absolute;
            bottom: 0;
            width: 80%;
            height: 29vh;
            background-color: rgba(255, 255, 255, 0);
            -webkit-overflow-scrolling: touch;
            overflow-x: auto;
            /* Enable horizontal scrolling */
            overflow-y: hidden;
            /* Prevent vertical scrolling */
            white-space: nowrap;
            /* Prevent wrapping of child elements */
        }

        #buttonContainer {
            display: flex;
            flex-wrap: nowrap;

            /* Prevent buttons from wrapping */
            align-items: center;
            justify-content: center;
            /* justify-content: space-around; */
            /* gap: 0px; */
            /* Center align items vertically */
            height: 20vh;
            /* Match the height of the container */
            padding: 10px;
            /* Optional: Add padding for spacing */
            box-sizing: border-box;
            pointer-events: none;
            /* Ignore pointer events */

            opacity: 0.4;
            /* Include padding and border in the element's total width and height */
        }

        #buttonContainer button {
            flex: 0 0 auto;
            /* Prevent buttons from stretching or shrinking */
            height: 20vh;
            /* Ensure buttons maintain their natural height */
            width: 20vh;
            max-width: 200px;
            /* Ensure buttons maintain their natural width */
            margin: 3vh;
            /* Optional: Add margin for spacing between buttons */
            color: #f0f0f000
        }


        .content {
            padding: 20px;
        }

        #dom-overlay::-webkit-scrollbar {
            width: 8px;
            /* Width of the scrollbar */
        }

        #dom-overlay::-webkit-scrollbar-thumb {
            background-color: #888;
            /* Color of the scrollbar */
            border-radius: 10px;
            /* Rounded edges */
        }

        #dom-overlay::-webkit-scrollbar-thumb:hover {
            background-color: #555;
            /* Darker on hover */
        }

        #dom-overlay::-webkit-scrollbar-track {
            background: #f0f0f0;
            /* Background of the scrollbar track */
        }
    </style>
</head>

<body>
    <a-scene log-when-loaded webxr="overlayElement:#dom-overlay">
        <!-- <a-sky src="./assets/equirectangular/first.jpg"></a-sky> -->
        <a-camera id="camera" position="0 1.6 0" rotation="0 0 0" near="0.1" far="1000">
           
            <a-box id="iconParent" position="0 1.5 -5"  color="#4CC3D9"> </a-box>

            <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
                <!-- <a-entity position="-4 0 0">
                    <a-box position="0 0 0" color="#4CC3D9" onclick="testCameraRotations()"></a-box>
                    <a-box position="2 0 0" color="#4CC3D9" onclick="testCameraRotations()"></a-box>
                    <a-box position="4 0 0" color="#4CC3D9" onclick="testCameraRotations()"></a-box>
                    <a-box position="6 0 0" color="#4CC3D9" onclick=""></a-box>
                    <a-box position="8 0 0" color="#4CC3D9" onclick=""></a-box>
                </a-entity> -->
        </a-camera>
        <!-- <a-camera look-controls="enabled: true" position="0 0 0" rotation="0 0 0"> -->

        <!-- Create 10 boxes lined up horizontally with a one meter gap -->



        <!-- </a-camera> -->
     



        <!-- <a-box position="3 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
            <a-box position="5 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
            <a-box position="7 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
            <a-box position="9 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
            <a-box position="11 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box> -->



    </a-scene>

    <div id="dom-overlay">

        <section id="my-interface">

            <div id="buttonContainer" class="scrollingButtonContainer">
                <button></button>
                <button></button>
                <button></button>
                <button></button>
                <button></button>

            </div>
        </section>
    </div>

</body>

</html>


<script>
    const iconParent = document.getElementById('iconParent');

    function scroll3D() {
        console.log("scrolling cubes")
        const scrollTop = event.target.scrollTop;
        const scrollLeft = event.target.scrollLeft;
        console.log('Scroll Top:', scrollTop);
        console.log('Scroll Left:', scrollLeft);
        iconParent.object3D.position.x = -scrollLeft * 0.01;
    }

    let cameraEL = document.querySelector('a-camera')
    let camera
    let scene = document.querySelector('a-scene')

    let renderer
    const scrollContainer = document.getElementById('dom-overlay');

    scrollContainer.addEventListener('scroll', scroll3D);

    function selectBox(box) {

        // console.log(iconParent.object3D.children[box].el.object3D.children[0].material);
        // iconParent.object3D.children[box].el.object3D.children[0].material = new THREE.MeshBasicMaterial({color: 0x0000ff});
        // .setAttribute('color', getRandomColor());
        // box.setAttribute('color', getRandomColor());

    }

    document.addEventListener('click', function (event) {
        // console.log('Mouse X:', event.clientX, 'Mouse Y:', event.clientY);
        const scene = document.querySelector('a-scene');
        const camera = document.querySelector('a-camera');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Convert the mouse position to normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Update the raycaster with the camera and mouse position
        raycaster.setFromCamera(mouse, camera.getObject3D('camera'));

        // Get the list of objects to test for intersections
        const objects = Array.from(scene.querySelectorAll('a-box')).map(box => box.object3D);
        // console.log('Objects:', objects);

        // Check if objects are correctly selected
        if (objects.length === 0) {
            // console.error('No objects found');
            return;
        }

        // Perform the intersection test
        const intersects = raycaster.intersectObjects(objects, true);

        if (intersects.length > 0) {
            console.log('Hit:', intersects[0].object.el);
            // Change the color of the intersected object
            intersects[0].object.el.setAttribute('color', getRandomColor());
        } else {
            // console.log('No hits');
        }
    });






    const cube = document.querySelector('#iconParent').object3D;


    // function updateCubePosition() {
    //     console.log(cube)

    //     console.log('Window inner height:', window.innerHeight, 'Window inner width:', window.innerWidth);

    //     let vh = window.innerHeight / 100;
    //     let vw = window.innerWidth / 100;

    //     let targetX = 50 * vw; // 50vw in pixels
    //     let targetY = 50 * vh; // 20vh in pixels
    //     // console.log(vh, vw);

    //     let ndcY = (targetY / window.innerHeight) * 2 - 1; // Convert to NDC
    //     let ndcX = (targetX / window.innerWidth) * 2 - 1; // Convert to 
    //     console.log('NDC X:', ndcX, 'NDC Y:', ndcY);

    //     console.log(camera)
    //     // let cameraEL = document.querySelector('a-camera')
    //     // const camera = cameraEl.getObject3D('camera');
    //     if (!camera) {
    //         console.error('Camera not found');
    //         return;
    //     }

    //     const vec = new THREE.Vector3(ndcX, ndcY, 0.5); // NDC coordinates

    //     vec.unproject(camera);
    //     console.log("unprojected vec", vec);

    //     vec.sub(camera.position).normalize();
    //     console.log("subbed", vec);

    //     const distance = -camera.position.z / vec.z;
    //     console.log('Camera position:', camera.position);
    //     console.log('Distance:', distance);

    //     const pos = new THREE.Vector3();
    //     // Perform the operation
    //     pos.copy(camera.position).add(vec.multiplyScalar(distance));

    //     console.log('Resulting pos:', pos);
    //     // cube.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
    //     // console.log("cube position", cube.getAttribute('position'))
    //     cube.position.copy(pos);
    //     // cube.lookAt(camera.getWorldPosition(new THREE.Vector3()));
    //     // Debugging: Log resulting vector

    // }
    const boxEl = document.querySelector('#iconParent');
    const box = boxEl;
    const cameraEl = document.querySelector('a-camera');

    function updateCubePosition() {
      console.log('Window inner height:', window.innerHeight);
      console.log('Window inner width:', window.innerWidth);
      let vh = window.innerHeight / 100;
      let vw = window.innerWidth / 100;

      let targetX = 50 * vw; // 50vw in pixels
      let targetY = 50 * vh; // 50vh in pixels

      let ndcY = (targetY / window.innerHeight) * 2 - 1; // Convert to NDC
      let ndcX = (targetX / window.innerWidth) * 2 - 1; // Convert to NDC

      console.log("screen space destination in uv", ndcX, ndcY);
      console.log("screen space destination in pixels", targetX, targetY);

      console.log(cameraEl);
      const camera = cameraEl.getObject3D('camera');
      if (!camera) {
        console.error('Camera not found');
        return;
      }

      // Create a vector at a fixed distance from the camera
      const fixedDistance = 5; // Fixed distance in meters
      const vec = new THREE.Vector3(ndcX, ndcY, 0.5); // NDC coordinates
      vec.unproject(camera);

      // Calculate the direction vector from the camera to the unprojected point
      vec.sub(camera.position).normalize();

      // Calculate the world position at the fixed distance
      const worldPosition = new THREE.Vector3();
      worldPosition.copy(camera.position).add(vec.multiplyScalar(fixedDistance));

      console.log('World position at fixed distance:', worldPosition);

      // Convert the world coordinates to the camera's local coordinates
      const localPosition = camera.worldToLocal(worldPosition.clone());
      console.log('Intersection point (local coordinates):', localPosition);

      // Set the box's position using the local coordinates
      boxEl.setAttribute('position', `${localPosition.x} ${localPosition.y} ${localPosition.z}`);

      // Align the box's rotation to match the camera's rotation
      const cameraRotation = cameraEl.getAttribute('rotation');
      boxEl.setAttribute('rotation', `${cameraRotation.x} ${cameraRotation.y} ${cameraRotation.z}`);
    }

    // function updateCubePosition() {


    //     console.log('Window inner height:', window.innerHeight);
    //     console.log('Window inner width:', window.innerWidth);
    //     let vh = window.innerHeight / 100;
    //     let vw = window.innerWidth / 100;

    //     let targetX = 50 * vw; // 50vw in pixels
    //     let targetY = 50 * vh; // 50vh in pixels

    //     let ndcY = (targetY / window.innerHeight) * 2 - 1; // Convert to NDC
    //     let ndcX = (targetX / window.innerWidth) * 2 - 1; // Convert to NDC

    //     console.log("screen space destination in uv", ndcX, ndcY);
    //     console.log("screen space destination in pixels", targetX, targetY);

    //     console.log(cameraEl);
    //     const camera = cameraEl.getObject3D('camera');
    //     if (!camera) {
    //         console.error('Camera not found');
    //         return;
    //     }

    //     // Create a ray from the camera through the NDC point
    //     const raycaster = new THREE.Raycaster();
    //     const mouse = new THREE.Vector2(ndcX, ndcY);
    //     raycaster.setFromCamera(mouse, camera);

    //     // Define a plane at a specific distance from the camera
    //     const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), -camera.position.z);

    //     // Find the intersection point of the ray with the plane
    //     const intersection = new THREE.Vector3();
    //     raycaster.ray.intersectPlane(planeZ, intersection);

    //     const localPosition = camera.worldToLocal(intersection.clone());
    //     console.log('Intersection point (local coordinates):', localPosition);

    //     // Set the box's position using the local coordinates
    //     boxEl.setAttribute('position', `${localPosition.x} ${localPosition.y} ${localPosition.z}`);

    //     // Align the box's rotation to match the camera's rotation
    //     // Calculate the desired world rotation for the box
    //     // const desiredWorldRotation = new THREE.Euler(0, 0, 0); // Example: no rotation

    //     // // Convert the world rotation to the camera's local rotation
    //     // const desiredQuaternion = new THREE.Quaternion().setFromEuler(desiredWorldRotation);
    //     // const cameraQuaternion = camera.quaternion.clone();
    //     // cameraQuaternion.invert();
    //     // const localQuaternion = desiredQuaternion.multiply(cameraQuaternion);
    //     // const localRotation = new THREE.Euler().setFromQuaternion(localQuaternion);

    //     // Set the box's rotation using the local rotation
    //     // boxEl.setAttribute('rotation', `${THREE.Math.radToDeg(localRotation.x)} ${THREE.Math.radToDeg(localRotation.y)} ${THREE.Math.radToDeg(localRotation.z)}`);
    // }

    // function onWindowResize() {
    //     renderer = scene.renderer

    //     cameraEL = document.querySelector('a-camera')
    //     camera = cameraEL.components.camera.camera


    //     console.log("updating")

    //     if (!camera) {
    //         console.error('Camera not found');
    //         return;
    //     }

    //     if (typeof updateCubePosition == 'undefined') {
    //         console.error('updateCubePosition not found');
    //         return;
    //     }
    //     if (typeof centerScrollbar == 'undefined') {
    //         console.error('centerScrollbar not found');
    //         return;
    //     }

    //     renderer.setSize(window.innerWidth, window.innerHeight);
    //     camera.aspect = window.innerWidth / window.innerHeight;
    //     camera.updateProjectionMatrix();

    //     updateCubePosition();
    //     // centerScrollbar()
    // }



    function centerScrollbar() {
        scrollContainer.removeEventListener('scroll', scroll3D);

        // console.log("centering")
        const container = document.getElementById('dom-overlay');
        // console.log(container)
        const contentWidth = container.scrollWidth;
        const containerWidth = container.clientWidth;

        // Calculate the scroll position to center the content
        const scrollPosition = (contentWidth - containerWidth) / 2;
        // Set the scroll position
        container.scrollLeft = scrollPosition;
        scrollContainer.addEventListener('scroll', scroll3D);



    }


    function testCameraRotations() {
        const cameraEl = document.querySelector('a-camera');
        // No rotation
        //   console.log("camera", cameraEl)
        console.log("rotation 1 ", cameraEL.getAttribute('rotation'))
        console.log("position 1 ", cameraEL.getAttribute('position'))

        //   cameraEl.setAttribute('rotation', {x: 15, y: 30, z: 90});
        //AFRAME.scenes[0].camera.rotation.set(0, 90, 0)

        //components.camera.camera.rotation.set(0, 0, 0)
        //   camera.rotation = THREE.Vector3(180, 90, 0);
        //   updateCubePosition();

        // Rotation 90 degrees on X axis
        setTimeout(() => {
            console.log("rotation 2 ", cameraEL.getAttribute('rotation'))
            console.log("position 2 ", cameraEL.getAttribute('position'))
            // AFRAME.scenes[0].camera.rotation.set(0, 0, 0)
            //   updateCubePosition();
        }, 2000);
    }


    function setbox2(mouseX, mouseY) {
            var mouse = new THREE.Vector2();
            var raycaster = new THREE.Raycaster();
            var camera = cameraEl.getObject3D('camera');
            // mouse.x = (mouseX / window.innerWidth) * 2 - 1;
            // mouse.y = - (mouseY / window.innerHeight) * 2 + 1;
            mouse.x = mouseX;
            mouse.y = mouseY;
            console.log(`Normalized mouse position: X=${mouse.x}, Y=${mouse.y}`);

            raycaster.setFromCamera(mouse, camera);
            var direction = raycaster.ray.direction.clone().normalize();
            var distance = 5; // Fixed distance in meters

            // Calculate the world position of the box
            var worldPosition = raycaster.ray.origin.clone().add(direction.multiplyScalar(distance));
            console.log(`World position: X=${worldPosition.x}, Y=${worldPosition.y}, Z=${worldPosition.z}`);

            // Convert the world coordinates to the camera's local coordinates
            var localPosition = camera.worldToLocal(worldPosition.clone());
            console.log('Local position:', localPosition);

            // Set the box's position using the local coordinates
            box.object3D.position.copy(localPosition);
            // box.object3D.lookAt(camera.getWorldPosition(new THREE.Vector3()));
        }

</script>