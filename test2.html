<!DOCTYPE html>
<html>

<head>
    <title>A-Frame Scene with Boxes</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>
    <script>
        AFRAME.registerComponent('log-when-loaded', {
            init: function () {
                console.log('Component has been loaded');
                cameraEL = document.querySelector('a-camera')
                // cameraEL.removeAttribute('look-controls')
                camera = cameraEL.components.camera.camera
                camera.fov = 75
                camera.far = 1000
                camera.near = 1
                camera.position.z = 5
         
                
                window.addEventListener('resize', onWindowResize, false);
                scene = document.querySelector('a-scene')
                renderer = scene.renderer
                setTimeout(() => {
                    updateCubePosition()
                }, 1);
               
            
            }
        });
    </script>
    <script>
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
    </script>
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            display: flex;
            justify-content: center;
            align-items: end;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f000;
        }

        #dom-overlay {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 29vh;
            background-color: rgba(255, 255, 255, 0);
            -webkit-overflow-scrolling: touch;
            overflow-x: auto;
            /* Enable horizontal scrolling */
            overflow-y: hidden;
            /* Prevent vertical scrolling */
            white-space: nowrap;
            /* Prevent wrapping of child elements */
        }

        #buttonContainer {
            display: flex;
            flex-wrap: nowrap;
            /* Prevent buttons from wrapping */
            align-items: center;
            justify-content: center;
            /* Center align items vertically */
            height: 20vh;
            /* Match the height of the container */
            padding: 10px;
            /* Optional: Add padding for spacing */
            box-sizing: border-box;
            pointer-events: none;
            /* Ignore pointer events */

            opacity: 0.4;
            /* Include padding and border in the element's total width and height */
        }

        #buttonContainer button {
            flex: 0 0 auto;
            /* Prevent buttons from stretching or shrinking */
            height: 20vh;
            /* Ensure buttons maintain their natural height */
            width: 20vh;
            max-width: 100px;
            /* Ensure buttons maintain their natural width */
            margin: 3vh;
            /* Optional: Add margin for spacing between buttons */
            color: #f0f0f000
        }


        .content {
            padding: 20px;
        }

        #dom-overlay::-webkit-scrollbar {
            width: 8px;
            /* Width of the scrollbar */
        }

        #dom-overlay::-webkit-scrollbar-thumb {
            background-color: #888;
            /* Color of the scrollbar */
            border-radius: 10px;
            /* Rounded edges */
        }

        #dom-overlay::-webkit-scrollbar-thumb:hover {
            background-color: #555;
            /* Darker on hover */
        }

        #dom-overlay::-webkit-scrollbar-track {
            background: #f0f0f0;
            /* Background of the scrollbar track */
        }
    </style>
</head>

<body>
    <a-scene log-when-loaded webxr="overlayElement:#dom-overlay">
        <a-sky src="./assets/equirectangular/first.jpg"></a-sky>
        <a-camera position="0 1.6 0">
            <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
            <!-- Create 10 boxes lined up horizontally with a one meter gap -->
            <a-entity id="iconParent" position="0 -2.5 -5">

                <!-- <a-box position="3 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="5 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="7 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="9 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="11 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box> -->

                <a-box position="-4 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="-2 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="0 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="2 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>
                <a-box position="4 0 0" color="#4CC3D9" onclick="this.setAttribute('color', getRandomColor())"></a-box>


            </a-entity>

        </a-camera>
    </a-scene>

    <div id="dom-overlay">

        <section id="my-interface">

            <div id="buttonContainer" class="scrollingButtonContainer">
                <button></button>
                <button></button>
                <button></button>
                <button></button>
                <button></button>

            </div>
        </section>
    </div>

</body>

</html>


<script>

    let cameraEL = document.querySelector('a-camera')
    let camera
    // const camera = cameraEL.el.components.camera.camera 
    // console.log(camera)
    // camera.far = 1000
    // camera.fov = 75

    // console.log(camera)
    let scene

    let renderer

    const iconParent = document.getElementById('iconParent');
    const scrollContainer = document.getElementById('dom-overlay');
    scrollContainer.addEventListener('scroll', (event) => {
        const scrollTop = event.target.scrollTop;
        const scrollLeft = event.target.scrollLeft;
        console.log('Scroll Top:', scrollTop);
        console.log('Scroll Left:', scrollLeft);
        console.log('iconParent', iconParent.object3D.position.x);
        iconParent.object3D.position.x =  -scrollLeft * 0.01;
        console.log('iconParent', iconParent.object3D.position.x);

        // Adjust the camera's Z position based on the scroll position
        // camera.position.z = 5 - scrollTop * 0.01; // Modify the multiplier for your needs
    });


    // function selectBox(box) {

    //     // console.log(iconParent.object3D.children[box].el.object3D.children[0].material);
    //     // iconParent.object3D.children[box].el.object3D.children[0].material = new THREE.MeshBasicMaterial({color: 0x0000ff});
    //     // .setAttribute('color', getRandomColor());
    //     // box.setAttribute('color', getRandomColor());

    // }

    // document.addEventListener('click', function (event) {
    //     console.log('Mouse X:', event.clientX, 'Mouse Y:', event.clientY);
    //     const scene = document.querySelector('a-scene');
    //     const camera = document.querySelector('a-camera');
    //     const raycaster = new THREE.Raycaster();
    //     const mouse = new THREE.Vector2();

    //     // Convert the mouse position to normalized device coordinates (-1 to +1)
    //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    //     // Update the raycaster with the camera and mouse position
    //     raycaster.setFromCamera(mouse, camera.getObject3D('camera'));

    //     // Get the list of objects to test for intersections
    //     const objects = Array.from(scene.querySelectorAll('a-box')).map(box => box.object3D);
    //     console.log('Objects:', objects);

    //     // Check if objects are correctly selected
    //     if (objects.length === 0) {
    //         console.error('No objects found');
    //         return;
    //     }

    //     // Perform the intersection test
    //     const intersects = raycaster.intersectObjects(objects, true);

    //     if (intersects.length > 0) {
    //         console.log('Hit:', intersects[0].object.el);
    //         // Change the color of the intersected object
    //         intersects[0].object.el.setAttribute('color', getRandomColor());
    //     } else {
    //         console.log('No hits');
    //     }
    // });

    // window.addEventListener('resize', () => {
    //     console.log('Window resized');
    //     const scene = document.querySelector('a-scene');
    //     const camera = document.querySelector('a-camera');



    //     // Update the camera aspect ratio and projection matrix
    //     camera.getObject3D('camera').aspect = window.innerWidth / window.innerHeight;
    //     camera.getObject3D('camera').updateProjectionMatrix();

    //     // Optionally, you can also adjust the renderer size if needed
    //     if (scene.renderer) {
    //         scene.renderer.setSize(window.innerWidth, window.innerHeight);
    //     }
    // });

    // document.addEventListener('DOMContentLoaded', function() {
    //     const camera = document.querySelector('a-camera');
    //     const iconParent = document.getElementById('iconParent');
    //     const boxes = iconParent.querySelectorAll('a-box');

    //     function updateBoxPositions() {
    //         const cameraWidth = window.innerWidth;
    //         console.log('cameraWidth', cameraWidth);
    //         const cameraHeight = window.innerHeight;

    //         // Calculate the new positions based on the camera's dimensions
    //         const basePositionX = cameraWidth / 1000; // Adjust this factor as needed
    //         const basePositionY = cameraHeight / 100; // Adjust this factor as needed

    //         boxes.forEach((box, index) => {
    //             const offsetX = (index - (boxes.length / 2)) * 2; // Adjust the spacing as needed
    //             console.log('basePositionX', basePositionX);
    //             box.setAttribute('position', `${0 + index + offsetX} 0 0`);
    //         });
    //     }

    //     // Initial update
    //     updateBoxPositions();

    //     // Update positions on window resize
    //     window.addEventListener('resize', updateBoxPositions);
    // });


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCubePosition();
    }


    const cube = iconParent


    function updateCubePosition() {

        console.log('Window inner height:', window.innerHeight);
        console.log('Window inner width:', window.innerWidth);
        const vh = window.innerHeight / 100;
        const vw = window.innerWidth / 100;

        const targetY = 1 * vh; // 20vh in pixels
        const targetX = 50 * vw; // 50vw in pixels
        console.log(vh, vw);


        const ndcY = (targetY / window.innerHeight) * 2 - 1; // Convert to NDC
        const ndcX = (targetX / window.innerWidth) * 2 - 1; // Convert to NDC

        const vec = new THREE.Vector3(ndcX, ndcY, 0.5); // NDC coordinates
        console.log("vec", vec);
        const pos = new THREE.Vector3();

        console.log("camera position", camera.position);
        vec.unproject(camera);
        console.log("unprojected vec", vec);
        vec.sub(camera.position).normalize();
        console.log("subbed", vec);
        console.log("camera", camera.position)
        const distance = -camera.position.z / vec.z;

        console.log('Camera position:', camera.position);
        console.log('Initial vec:', vec);
        console.log('Distance:', distance);

        // Perform the operation
        pos.copy(camera.position).add(vec.multiplyScalar(distance));

        // Debugging: Log resulting vector
        console.log('Resulting pos:', pos);

        // cube.position.copy(pos);
        cube.setAttribute('position', pos);

    }

</script>